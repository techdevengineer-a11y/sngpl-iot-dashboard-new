"""
Standalone MQTT Listener Service
Runs independently from the main FastAPI application
Processes IoT device data and saves to database
"""

import paho.mqtt.client as mqtt
import json
import sys
import os
import asyncio
import threading
import time
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# Add parent directory to path to import app modules
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.core.config import settings
from app.core.logging_config import get_logger
from app.models.models import Device, DeviceReading, Alarm, AlarmThreshold

logger = get_logger("mqtt_listener")

# Create database engine and session for standalone script (PostgreSQL)
engine = create_engine(
    settings.DATABASE_URL,
    pool_size=settings.DB_POOL_SIZE,
    max_overflow=settings.DB_MAX_OVERFLOW,
    pool_pre_ping=True,
    pool_recycle=settings.DB_POOL_RECYCLE,
    pool_timeout=30,
    connect_args={
        "connect_timeout": 10,
        "application_name": "sngpl_iot_mqtt_listener"
    }
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


class StandaloneMQTTListener:
    """Standalone MQTT listener that runs independently"""

    def __init__(self):
        self.client = None
        self.connected = False
        self.offline_check_thread = None
        self.running = False
        logger.info("Standalone MQTT Listener initialized")
        logger.info(f"Broker: {settings.MQTT_BROKER}:{settings.MQTT_PORT}")
        logger.info(f"Topic: {settings.MQTT_TOPIC}")
        logger.info(f"Database: {settings.DATABASE_URL}")

    def on_connect(self, client, userdata, flags, rc):
        """Callback when connected to MQTT broker"""
        if rc == 0:
            logger.info(f"[OK] Connected to MQTT Broker: {settings.MQTT_BROKER}")
            self.connected = True
            # Subscribe to multiple topics
            client.subscribe(settings.MQTT_TOPIC)
            logger.info(f"[OK] Subscribed to topic: {settings.MQTT_TOPIC}")
            client.subscribe("evc/topic")
            logger.info(f"[OK] Subscribed to topic: evc/topic")
            # Subscribe to wildcard to catch all evc messages
            client.subscribe("evc/#")
            logger.info(f"[OK] Subscribed to topic: evc/# (wildcard)")
            print(f"\n[INFO] MQTT Listener is now running and waiting for messages...")
            print(f"[INFO] Subscribed to topics:")
            print(f"       - {settings.MQTT_TOPIC} (Primary topic)")
            print(f"       - evc/topic (Additional topic)")
            print(f"       - evc/# (All evc messages - wildcard)")
            print(f"[INFO] Press Ctrl+C to stop\n")
        else:
            logger.error(f"[ERROR] Failed to connect to MQTT Broker, return code {rc}")
            print(f"[ERROR] Connection failed with code {rc}")

    def on_disconnect(self, client, userdata, rc):
        """Callback when disconnected from MQTT broker"""
        self.connected = False
        if rc == 0:
            logger.info("[INFO] Disconnected from MQTT Broker (intentional)")
        else:
            logger.warning(f"[WARNING] Unexpected disconnection from MQTT Broker, return code {rc}")
            print(f"[WARNING] Disconnected from broker. Attempting to reconnect...")

    def on_message(self, client, userdata, msg):
        """Callback when message received from MQTT broker"""
        try:
            # Decode and parse message
            raw_payload = msg.payload.decode('utf-8', errors='ignore')

            # Try to parse as JSON
            try:
                payload = json.loads(raw_payload)
            except json.JSONDecodeError as e:
                logger.warning(f"Malformed JSON on topic {msg.topic}: {raw_payload[:100]}... Error: {e}")
                print(f"[WARNING] Malformed JSON received: {raw_payload[:100]}")
                return

            # Print incoming message to console
            device_id = payload.get("did", "unknown")
            print(f"\n{'='*60}")
            print(f"[MQTT] Message received on topic: {msg.topic}")
            print(f"[MQTT] Device ID: {device_id}")
            print(f"[MQTT] Raw data: {json.dumps(payload, indent=2)}")
            print(f"{'='*60}")

            logger.debug(f"Received message on topic {msg.topic}: {payload}")

            # Process the data
            self.process_device_data(payload)

        except Exception as e:
            logger.error(f"Error processing MQTT message: {e}", exc_info=True)
            print(f"[ERROR] Failed to process message: {e}")

    def process_device_data(self, data):
        """Process device data and save to database"""
        db = SessionLocal()

        try:
            # Get device ID from 'did' field (try multiple possible field names)
            client_id = data.get("did", data.get("device_id", data.get("client_id", ""))).strip()

            if not client_id:
                logger.warning(f"No device ID in MQTT message, skipping. Payload keys: {list(data.keys())}")
                print(f"[WARNING] No device ID found. Available fields: {list(data.keys())}")
                return

            # Find or create device
            device = db.query(Device).filter(Device.client_id == client_id).first()

            if not device:
                # Create new device if it doesn't exist
                # Automatically assign to OTHER section if not SMS device
                device_type = "OTHER" if not client_id.startswith("SMS-") else "SMS"

                logger.info(f"Creating new {device_type} device: {client_id}")
                device = Device(
                    client_id=client_id,
                    device_name=f"Device {client_id}",
                    device_type=device_type,
                    location="Unknown",
                    latitude=0.0,
                    longitude=0.0,
                    is_active=True
                )
                db.add(device)
                db.commit()
                db.refresh(device)
                logger.info(f"[OK] {device_type} device {client_id} created successfully with ID {device.id}")

            # Update last seen
            device.last_seen = datetime.now()
            device.is_active = True

            # Parse content array to get sensor values
            content = data.get("content", [])
            sensor_data = {}

            if content and isinstance(content, list):
                for item in content:
                    if isinstance(item, dict):
                        addr = item.get("Addr")
                        value = float(item.get("Addrv", 0))
                        sensor_data[addr] = value
            else:
                # If content is not in expected format, try to extract values directly from data
                logger.info(f"[INFO] Content not in expected array format for {client_id}, checking for direct fields")
                print(f"[INFO] Parsing alternative data format for {client_id}")

            # Create device reading
            # CORRECT MAPPING: T13 = Total Volume Flow (MCF/day), T14 = Volume (MCF)
            reading = DeviceReading(
                device_id=device.id,
                client_id=client_id,
                temperature=sensor_data.get("T12", 0.0),
                static_pressure=sensor_data.get("T11", 0.0),
                differential_pressure=sensor_data.get("T10", 0.0),
                volume=sensor_data.get("T14", 0.0),              # T14 = Volume (MCF)
                total_volume_flow=sensor_data.get("T13", 0.0),  # T13 = Total Volume Flow (MCF/day)
                battery=sensor_data.get("Battery", None),         # Battery level (%) - if available
                timestamp=datetime.now()
            )
            db.add(reading)

            # Check alarm thresholds
            alarms_created = self.check_alarms(db, device.id, client_id, reading)

            db.commit()

            # Print to console and log
            save_message = (
                f"[DATABASE] Saved reading for {client_id} | "
                f"Temp: {reading.temperature:.1f}°F | "
                f"Pressure: {reading.static_pressure:.1f} PSI | "
                f"Diff Pressure: {reading.differential_pressure:.1f} IWC | "
                f"Volume: {reading.volume:.1f} MCF | "
                f"Volume Flow: {reading.total_volume_flow:.1f} MCF/day"
            )
            print(f"[OK] {save_message}")
            logger.info(save_message)

            if alarms_created:
                alarm_msg = f"[ALARM] {len(alarms_created)} alarm(s) triggered for {client_id}"
                print(f"⚠️  {alarm_msg}")
                logger.warning(alarm_msg)
                for alarm in alarms_created:
                    alarm_detail = f"  - {alarm.parameter}: {alarm.value} ({alarm.threshold_type} threshold, {alarm.severity} severity)"
                    print(alarm_detail)
                    logger.warning(alarm_detail)

        except Exception as e:
            error_msg = f"[ERROR] Error saving device data for {client_id}: {e}"
            print(error_msg)
            logger.error(error_msg, exc_info=True)
            db.rollback()

        finally:
            db.close()

    def check_alarms(self, db: Session, device_id: int, client_id: str, reading: DeviceReading):
        """Check if readings exceed alarm thresholds"""
        # Get thresholds for this specific device only
        thresholds = db.query(AlarmThreshold).filter(
            AlarmThreshold.device_id == device_id,
            AlarmThreshold.is_active == True
        ).all()
        alarms_created = []

        parameters = {
            "temperature": reading.temperature,
            "static_pressure": reading.static_pressure,
            "differential_pressure": reading.differential_pressure,
            "volume": reading.volume,
            "total_volume_flow": reading.total_volume_flow,
            "battery": reading.battery if hasattr(reading, 'battery') else None
        }

        for threshold in thresholds:
            param_value = parameters.get(threshold.parameter)

            if param_value is None:
                continue

            # Check low threshold
            if threshold.low_threshold and param_value < threshold.low_threshold:
                alarm = self.create_alarm(
                    db, device_id, client_id, threshold.parameter, param_value,
                    "low", threshold.low_threshold,
                    f"{threshold.parameter} is below minimum threshold"
                )
                if alarm:
                    alarms_created.append(alarm)

            # Check high threshold
            if threshold.high_threshold and param_value > threshold.high_threshold:
                alarm = self.create_alarm(
                    db, device_id, client_id, threshold.parameter, param_value,
                    "high", threshold.high_threshold,
                    f"{threshold.parameter} is above maximum threshold"
                )
                if alarm:
                    alarms_created.append(alarm)

        return alarms_created

    def create_alarm(self, db: Session, device_id: int, client_id: str, parameter: str,
                    value: float, threshold_type: str, threshold_value: float, message: str):
        """Create alarm"""
        # Determine severity
        severity = "medium"
        if threshold_type == "high" and value > threshold_value * 1.2:
            severity = "high"
        elif threshold_type == "low" and value < threshold_value * 0.8:
            severity = "high"

        alarm = Alarm(
            device_id=device_id,
            client_id=client_id,
            parameter=parameter,
            value=value,
            threshold_type=threshold_type,
            severity=severity,
            is_acknowledged=False
        )
        db.add(alarm)
        return alarm

    def check_offline_devices(self):
        """Background task to check for offline devices every 10 seconds"""
        logger.info("[OFFLINE MONITOR] Starting offline device monitoring thread")
        print("[INFO] Offline device monitoring started (1-minute timeout)")

        while self.running:
            try:
                db = SessionLocal()
                try:
                    # Get current time
                    now = datetime.now()
                    # Calculate threshold time (1 minute ago)
                    threshold_time = now - timedelta(seconds=60)

                    # Find devices that were active but haven't sent data in 1 minute
                    offline_devices = db.query(Device).filter(
                        Device.is_active == True,
                        Device.last_seen < threshold_time
                    ).all()

                    if offline_devices:
                        for device in offline_devices:
                            device.is_active = False
                            logger.warning(f"[OFFLINE] Device {device.client_id} marked as offline (last seen: {device.last_seen})")
                            print(f"⚠️  [OFFLINE] Device {device.client_id} is now OFFLINE (no data for 1 minute)")

                        db.commit()

                except Exception as e:
                    logger.error(f"[ERROR] Error checking offline devices: {e}", exc_info=True)
                    db.rollback()
                finally:
                    db.close()

                # Sleep for 10 seconds before next check
                time.sleep(10)

            except Exception as e:
                logger.error(f"[ERROR] Offline check thread error: {e}", exc_info=True)
                time.sleep(10)

        logger.info("[OFFLINE MONITOR] Offline device monitoring thread stopped")

    def start(self):
        """Start MQTT client in blocking mode"""
        self.client = mqtt.Client()
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect
        self.client.on_message = self.on_message

        try:
            print(f"\n{'='*60}")
            print(f"  SNGPL IoT - Standalone MQTT Listener")
            print(f"{'='*60}")
            print(f"  Broker:   {settings.MQTT_BROKER}:{settings.MQTT_PORT}")
            print(f"  Topic:    {settings.MQTT_TOPIC}")
            print(f"  Database: {settings.DATABASE_URL}")
            print(f"{'='*60}\n")
            print(f"[INFO] Connecting to MQTT broker...")
            print(f"[INFO] Waiting for incoming MQTT messages...")
            print(f"[INFO] All received data will be displayed below:")
            print(f"{'='*60}\n")

            self.client.connect(settings.MQTT_BROKER, settings.MQTT_PORT, 60)

            # Start offline monitoring thread
            self.running = True
            self.offline_check_thread = threading.Thread(target=self.check_offline_devices, daemon=True)
            self.offline_check_thread.start()

            # Run forever (blocking)
            self.client.loop_forever()

        except KeyboardInterrupt:
            print("\n\n[INFO] Shutting down MQTT listener...")
            self.stop()
            print("[OK] MQTT listener stopped successfully")

        except Exception as e:
            logger.error(f"[ERROR] Error connecting to MQTT broker: {e}", exc_info=True)
            print(f"\n[ERROR] Failed to connect to MQTT broker: {e}")
            print("[INFO] Please check your network connection and broker settings")
            sys.exit(1)

    def stop(self):
        """Stop MQTT client"""
        self.running = False
        if self.offline_check_thread and self.offline_check_thread.is_alive():
            self.offline_check_thread.join(timeout=5)
        if self.client:
            self.client.disconnect()
            self.connected = False


def main():
    """Main entry point"""
    listener = StandaloneMQTTListener()
    listener.start()


if __name__ == "__main__":
    main()
